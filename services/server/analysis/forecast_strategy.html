<!DOCTYPE html>
<meta charset="utf-8">

<head>
	<style>



	</style>
</head>

<body>
	
<script src="https://d3js.org/d3.v5.min.js"></script>

<div id+"plot"></div>
<script>

var d= new Object()
var enter_long=0, exit_long=0, enter_short=0, exit_short=0;
var daily_pos= new Array()
var term=0;

var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;
	
var x = d3.scaleTime().range([0, width]);
var y = d3.scaleLinear().range([height, 0]);

var parseTime = d3.timeParse("%m/%d/%Y");

// define the line
var valueline = d3.line()
    .x(function(m) { return x(m[0]); })
    .y(function(m) { return y(m[1]); });

// append the svg obgect to the body of the page
// appends a 'group' element to 'svg'
// moves the 'group' element to the top left margin
var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

d3.json("output_13Apr.json").then(function(data){
	console.log(data);
	console.log('Number of buckets:', data.move.length);
	num_buckets=data['move'].length;
	
	
	if (num_buckets>2){
		mid_bucket=num_buckets/2;
		enter_long=mid_bucket;
		exit_long=mid_bucket;
		enter_short=mid_bucket;
		exit_short=mid_bucket;
	}
	
	d=data
	term=data['term'][0]
	calc_return()
	
});

function calc_return(){
	console.log("Enter long:", enter_long);
	console.log(d);
	var moves=d.move;  //list of buckets
	var owned_long=false, owned_short=false;
	var exit_long=0.0
	var cum_ret=new Array()
	
	
	for (i=0; i<d['dates'].length; i++){
		d['dates'][i]=parseTime(d['dates'][i]);
	}
	
	console.log('moves:', moves)
	
	for (i=0; i<d['predict']['term_'+term]['predict'].length; i++){
		var predict_move=d['predict']['term_'+term]['predict'][i];
		
		//check long position
		if(owned_long==false && predict_move>=enter_long){
			owned_long=true;
			exit_long=d['price'][i]*(1.0+d['move'][exit_long]);
			console.log('Entered long '+d['dates'][i]);
			daily_pos.push(0);
		}
		else if(owned_long==true && d['price'][i]>=exit_long){
			owned_long=false;
			daily_pos.push(1);
			console.log('Exit long '+d['dates'][i]);
		}
		else if(owned_long==true){
			daily_pos.push(1);
		}
		
		//check short position
		else if(owned_short==false && predict_move<=enter_short){
			owned_short=true;
			exit_short=d['price'][i]*(1.0+d['move'][exit_short]);
			console.log('Entered short '+d['dates'][i]);
			daily_pos.push(0);
		}
		else if(owned_short==true && d['price'][i]<=exit_short){
			owned_short=false;
			daily_pos.push(-1);
			console.log('Exit short '+d['dates'][i]);
		}
		else if(owned_short==true){
			daily_pos.push(-1);
		}
		
		//enter 0 if no position
		else{
			daily_pos.push(0);
		}
	};
	
	console.log('Daily position: ', daily_pos);
	cum_ret.push(daily_pos[0]*d['daily_ret'][0])
	for (i=1;i<d['daily_ret'].length;i++){
		cum_ret.push(cum_ret[i-1]+daily_pos[i]*d['daily_ret'][i])
	}
	console.log('Cum return: ', cum_ret);
	d['strat_cum_ret']=cum_ret;
	plotStrat();
	plotPrice();
	plotBollinger();

};


function plotPrice(){

	plot_data_stock=d3.zip(d.dates,d.cum_return);
	console.log('price data:', plot_data_stock);
	
	// Add the valueline path.
	svg.append("path")
      .data([plot_data_stock])
      .attr("fill", "none")
      .attr("stroke", "red")
      .attr("stroke-width", 1.5)
      .attr("d", function(m){return valueline(m);});
}


function plotBollinger(){

	plot_data_bollinger=d3.zip(d.dates,d.strategy.bollinger.cum_return);
	console.log('price data:', plot_data_stock);
	
	// Add the valueline path.
	svg.append("path")
      .data([plot_data_bollinger])
      .attr("fill", "none")
      .attr("stroke", "green")
      .attr("stroke-width", 1.5)
      .attr("d", function(m){return valueline(m);});

}


function plotStrat(){
	console.log('d in plotStrat:', d);
	
	console.log('X extent: ', d3.extent(d.dates));
	console.log('Y max: ', d3.max(d.strat_cum_ret));
	
	plot_data=d3.zip(d.dates,d.strat_cum_ret)
	console.log('data to plot:', plot_data);
	//d3.select("#plot").selectAll("g > *").remove;
	// Scale the range of the data
		
	x.domain(d3.extent(d.dates));
	y.domain([-d3.max(d.strat_cum_ret)*2, 2*d3.max(d.strat_cum_ret)]);

  // Add the valueline path.
	svg.append("path")
      .data([plot_data])
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-width", 1.5)
      .attr("d", function(m){return valueline(m);});
	  
	// Add X axis --> it is a date format
    
    svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));

    // Add Y axis
    
    svg.append("g")
      .call(d3.axisLeft(y));
	
}

  </script>
</body>